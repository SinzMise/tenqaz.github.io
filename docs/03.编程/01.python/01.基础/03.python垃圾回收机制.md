---
title: python垃圾回收机制
date: 2022-08-10 00:00:00
permalink: /pages/78c648/
author: 
  name: zhengwenfeng
  link: https://github.com/tenqaz
description: python的垃圾回收机制的几种方式：引用计数、标记清楚及分代回收，介绍他们的原理。
feed: 
  enable: true
tags: 
  - python
categories: 
  - 编程
  - python
  - 基础
---



## 引用计数

每次对象被引用时，会被计数加1，当计数为0时，则回收该对象。

**注意：** 循环引用的情况，引用计数不能解决.

![](https://gcore.jsdelivr.net/gh/tenqaz/BLOG-CDN@main/20220907215650.png)

## 标记-清除

对所有活跃的对象进行标记，对非活跃对象进行回收。可以有效的解决`循环引用`的问题

**原理**
对象之间通过引用构建有向图，从root object(全局变量，寄存器等不可删除的对象)出发，沿着有向边遍历对象，可达的对象标记为活跃对象，不可达的对象就是要被清除的非活动对象。

在下图中，从黑点开始出发，1对象可达，2、3间接可达，1、2、3是活跃对象，4,5不可达，所以是非活跃对象，进行回收。
![在这里插入图片描述](https://gcore.jsdelivr.net/gh/tenqaz/BLOG-CDN@main/1604800087645.png#alt=)

**过程**
找到root object集合, 在内存建立两条连表，一条链表维护root object集合，另一条链表哦维护剩下的对象，在标记的过程中，如果在`不可达链表中`存在被root链表中的独享，直接或间接引用独享，就将其从不可达链表移到root链表中。当完成标记后，`不可达链表`剩下的对象都是垃圾对象，进行回收。

## 分代回收

对象分在不同集合中，每个集合称为一个`代`, Python中分为3代，年轻代(第0代)、中年代(第1代)、老年代(第二代)，对应3各链表，每一代GC频率不同，第0代最高，第1代次之，第二代最低(越年轻的对象越容易死掉，而老的对象通常会存错更久)，新生的对象放入第0代，如果该对象在第0代的一次GC中存活，则移动到第1代，如果第一代对象在第1代GC中存错，则移动到第2代。

什么情况触发GC， 可以设置阈值，也可以手动调用`gc.collect()`

每次扫描全部对象，费时费力，提高GC的效率。



## 垃圾回收触发情况

调用`gc.collect()`,需要先导入gc模块。

当`gc`模块的计数器达到阈值的时候。阈值可以设置